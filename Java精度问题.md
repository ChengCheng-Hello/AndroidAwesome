## Java 精度问题

### 基本数据类型

#### 字符型

1. byte：字节。
   - 占用空间： 1 字节。
   - 取值范围：-2^7^~2^7^-1，即 -128 ~ 127.

#### 整型

1. char：字符，使用 Unicode 编码。
   - 占用空间：2 字节。
   - 取值范围：0 ~ 2^16^-1，即 0 ~ 65535。
2. short：表示短整数。
   - 占用空间：2 字节。
   - 取值范围：-2^15^ ~ 2^15^-1，即 -32768 ~ 32767。
3. int：表示整数。
   - 占用空间：4 字节。
   - 取值范围：-2^31^ ~ 2^31^-1，即 -2147483648 ~ 2147483647。（ 21 亿，10 位数 ）
4. long：表示长整数。
   - 占用空间：8 字节。
   - 取值范围：-2^63^ ~ 2^63^-1，即 -9223372036854774808 ~ 9223372036854774807。


#### 浮点型

- Java 的浮点数采用 IEEE 754 标准，即数字分为 符号位、指数位、尾数位。
- 浮点型的数据不能完全精确。

1. float：表示单精度浮点数。
   - 占用空间：4 字节。
   - 取值范围：3.402823e+38～1.401298e-45。
2. double：表示双精度浮点数。
   - 占用空间：8 字节。
   - 取值范围：1.797693e+308～4.9000000e-324。

#### 布尔型

1. boolean：表示布尔类型，取值 true、false。因此，在空间占用上，只需要 1bit 即可。

   ​

### 浮点数精度问题

1. 如 0.1 的 double 类型实际的值是 0.1000000000000000055511151231257827021181583404541015625。

   这是因为二进制无法精确的表示小数，只是一个十分接近的数字。

2. 1.1 + 0.1 = 1.2000000000000002。

   原因参考：[如何理解double精度丢失问题？ - 邱昊宇的回答 - 知乎](https://www.zhihu.com/question/42024389/answer/93528601)。

3. [浅谈java的浮点数精度问题](https://blog.csdn.net/abing37/article/details/5332798)。



#### 解决浮点数精度问题

Java 中可以使用 BigDecimal 来进行计算。

需要注意构造方法的区别。

```java
double a = 0.1;

// 如果使用 double 的构造方法，b1 的取值是 0.1000000000000000055511151231257827021181583404541015625
BigDecimal b1 = new BigDecimal(a);

// 所以需要使用 string 的构造方法，b2 的取值是 0.1
BigDecimal b2 = new BigDecimal(Double.toString(a));

// BigDecimal 有自己的运算方法
BigDecimal b3 = b1.add(b2);
// add 之后，并不会改变 b1 的值，所有运算方法都会生成一个新的 BigDecimal 对象。
```



### 注意

- 浮点型 float、double 进行 == 判断时，是不准确的，需要避免这种判断方式。
- int 类型进行一些数值的计算时，需要注意取值范围，很容易发生溢出。特别是最终取值是 int 范围内，但是计算过程先进行乘法，再进行除法，可能乘法就会导致溢出，执行不到除法。